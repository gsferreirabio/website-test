[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction To R",
    "section": "",
    "text": "Welcome to the website of the Introduction to R course (Geow-M317_325-21-16). This short course is part of the Data Analysis and Modeling Methods in Geoscience and Environmental Science module of the Geosciences Department (Uni. Tübingen) and is developed and taught by Gabriel Ferreira.\nThe Intro to R course aims to provide a brief introduction to using the R programming language and environment in a data science context, particularly for students in the areas of Geology and Palaeontology. With a lot of hands-on exercises, the students are expected to feel comfortable to use and explore the many possibilities provided by R.\nYou can use the sidebar to navigate through the different code presented in each day of the course.\nWe will use the RStudio integrated development environment (IDE) for R during this course. You can either install on your own machine or create a free account to use the cloud version of it (but keep in mind that the computing power and hours are limited with the free account, so this might not be enough — particularly in the last days of the course). Make sure to update R (https://cran.r-project.org/bin/windows/base/) and RStudio (https://posit.co/download/rstudio-desktop/) as this page will be kept up-to-date using the latest version.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "yourfunction.html",
    "href": "yourfunction.html",
    "title": "Writing your functions",
    "section": "",
    "text": "Maybe you want to automatize a process for which you cannot find an already written function, or maybe you want to customize a function to your needs. R enables you to write your own functions using function() and defining the set of steps that will be performed by this function. Of course, they can be stored in objects, which will then be treated as the names of your functions.\nLet’s create a function to calculate the median of a distribution. The median is a value that separates the distribution in half. In a distribution with an odd number of elements, the element in the center of this distribution (when sorted from minimum to maximum or the opposite) is the median.\n\nodd.dist &lt;- c(1, 3, 5, 7, 9)\nlength(odd.dist)/2\n\n[1] 2.5\n\n# because this is not an integer, we will round it upwards\nodd.dist[ceiling(length(odd.dist)/2)]\n\n[1] 5\n\n\nThis becomes a bit more difficult when the distribution has an even number of elements, because there is no single position at the middle. What is done then is to calculate the average between the values in the two positions before and after the center of the distribution.\n\neven.dist &lt;- c(2, 4, 6, 8)\nmedian(even.dist)  \n\n[1] 5\n\n\nFive is not a number in the even.dist, but is the mean between 4 and 6. Thus, a function to calculate the mean will require four steps: 1. order the sequence 2. check whether the sequence is even or odd 3a. if it is odd, select the number in the center position 3b. if it is even, calculate the mean between the numbers before and after the center position\nIt is always useful to check if each step in your code successfully runs by itself. Let’s do this:\n\n# Step 1: Order the sequence\nnew.seq &lt;- c(1, 5, 3, 9, 7, 11)\nsort(new.seq)\n\n[1]  1  3  5  7  9 11\n\n# Step 2: Odd or even?\nlength(even.dist)%%2 == 0  ## dividing even.dist by 2 leaves nothing\n\n[1] TRUE\n\nlength(odd.dist)%%2 == 0\n\n[1] FALSE\n\n# Step 3a: if odd, select the number in the center position\nodd.dist[length(odd.dist)/2]\n\n[1] 3\n\n# Step 3b: if even, calculate the mean between the numbers before \n## and after the center position\nbef &lt;- even.dist[length(even.dist)/2]\naft &lt;- even.dist[1 + length(even.dist)/2]\n(bef + aft)/2\n\n[1] 5\n\n\nNow we can put all those steps together in a single function and use it to calculate the median of the new.seq and the even.dist objects.\n\ncalculate.median &lt;- \n  function(x) {\n    odd.even &lt;- length(x)%%2\n    ## we are going to use if/else statements\n    if (odd.even == 0) {  \n      (sort(x)[length(x)/2] + sort(x)[1 + length(x)/2])/2\n    }\n    else sort(x)[ceiling(length(x)/2)]\n  }\n\ncalculate.median(new.seq)\n\n[1] 6\n\ncalculate.median(even.dist)\n\n[1] 5\n\n\nFinally, you might want to save this function so that you can load it in another script, without the need to rewriting it all over. To save and load a function (or any object, actually), use:\n\nsave(calculate.median, file = \"calculate.median.R\")\n\n# and to load it in another session\nload(file = \"calculate.median.R\")",
    "crumbs": [
      "Basics in R",
      "Writing your functions"
    ]
  },
  {
    "objectID": "Rascalculator.html",
    "href": "Rascalculator.html",
    "title": "R as a calculator",
    "section": "",
    "text": "R is a very complete calculator that allows you to perform from simple arithmetic operations to solve complex equations. The basic arithmetic operators for addition, subtraction, multiplication and division in R are:\n\n2+2  ## addition\n\n[1] 4\n\n2-2  ## subtraction\n\n[1] 0\n\n2*2  ## multiplication\n\n[1] 4\n\n2/2  ## division\n\n[1] 1\n\n\nYou can pass multiple operations in a single line of code, but keep in mind that some operators have priorities over others, so use parameters to keep the desired operation order.\n\n2+3+5+10+25-2  ## multiple operations\n\n[1] 43\n\n2+3*4  ## multiplications and divisions are done first\n\n[1] 14\n\n2+10/5\n\n[1] 4\n\n3^2/2  ## but power comes first\n\n[1] 4.5\n\n# Parenthesis are useful to determine the order of operations\n3^(2/2)\n\n[1] 3\n\n\nR deals with large numbers using the e character followed by the number of positions the decimal point will move. If the number is positive, the decimal point moves to the right; if negative it moves to the left.\n\n1.2e3 \n\n[1] 1200\n\n1.2e-2 \n\n[1] 0.012\n\n\n\nLogical operators\nBoolean algebra (operations that return True or False values) can be done using the == (double equal signs = “equals to”) and != (“not” operator (!) followed by equal sign = “differs from”) logical operators:\n\n1 == 1\n\n[1] TRUE\n\n1 == 2\n\n[1] FALSE\n\n1 != 1\n\n[1] FALSE\n\n1 != 2\n\n[1] TRUE\n\n\nThe returned values from Boolean operations are TRUE and FALSE (always in capital letters), which can also be expressed by the single capital letters T and F, respectively.\n\nT == TRUE\n\n[1] TRUE\n\nF == FALSE\n\n[1] TRUE\n\n\n“Greater than” (&gt;), “smaller than or equal to” (&lt;=), “and” (&), “or” (|) are all logical operators that can be used in R.\n\n1 & 2 &gt; 3  ## 1 and 2 are greater than 0\n\n[1] FALSE\n\n1 | 10 &lt;= 5  ## 1 or 10 is smaller or equal to 5\n\n[1] TRUE\n\n\n\n\nAdditional signs\nTwo dots (:) can be used to create a sequence.\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n2.5:5.5\n\n[1] 2.5 3.5 4.5 5.5\n\n\nAnd the modulo operation (the remainder of a division) can be done using “%%”:\n\n2%%2\n\n[1] 0\n\n3%%2\n\n[1] 1\n\n\n\n\nMissing and null values\nMissing values in R are represented by the special object NA (“not available”). NAs reserve space in a vector, which is important to keep the original dimensions, but they can be very annoying when using some functions. We will see how to identify and deal with them in the Functions section. On the other hand, the special object NULL represents the absence of a value and indicates that an object contains no data. It can be used for example to create an object that will be fill with values later in a function to to remove the content of a preexisting object.",
    "crumbs": [
      "Basics in R",
      "R as a calculator"
    ]
  },
  {
    "objectID": "gettinghelp.html",
    "href": "gettinghelp.html",
    "title": "Getting help",
    "section": "",
    "text": "The first place to get help with R is the Comprehensive R Archive Network, where you can find many resources about R, such as manuals and FAQs, and also general announcements from the developers.\nDirectly in RStudio you can open the Help page (on the Help tab, usually on the bottom right panel) by running “?” followed by the name of the function or package:\n\n?read.table\n\nIf you cannot remember the exact name of a function, but remember its subject, you can use the help.search() function passing what you remember as an argument.\n\nhelp.search(\"csv\")  ## then use ? read.table for more precise info\n\nThe function find() finds which package a given function is in (more on packages and functions later); apropos() returns the objects and functions that match the argument you pass to it; example() and demo() take function names as arguments and are useful to learn how those functions work.\n\n# Try using those functions\nfind(\"max\")\n\napropos(\"lm\")\n\nexample(lm)\ndemo(graphics)\n\nFinally, knowing the version of R you are using and how to cite it (do not forget to cite it!) are always useful and can be done as follows:\n\nversion\n\n               _                                \nplatform       x86_64-w64-mingw32               \narch           x86_64                           \nos             mingw32                          \ncrt            ucrt                             \nsystem         x86_64, mingw32                  \nstatus                                          \nmajor          4                                \nminor          5.2                              \nyear           2025                             \nmonth          10                               \nday            31                               \nsvn rev        88974                            \nlanguage       R                                \nversion.string R version 4.5.2 (2025-10-31 ucrt)\nnickname       [Not] Part in a Rumble           \n\ncitation()\n\nTo cite R in publications use:\n\n  R Core Team (2025). _R: A Language and Environment for Statistical\n  Computing_. R Foundation for Statistical Computing, Vienna, Austria.\n  &lt;https://www.R-project.org/&gt;.\n\nA BibTeX entry for LaTeX users is\n\n  @Manual{,\n    title = {R: A Language and Environment for Statistical Computing},\n    author = {{R Core Team}},\n    organization = {R Foundation for Statistical Computing},\n    address = {Vienna, Austria},\n    year = {2025},\n    url = {https://www.R-project.org/},\n  }\n\nWe have invested a lot of time and effort in creating R, please cite it\nwhen using it for data analysis. See also 'citation(\"pkgname\")' for\nciting R packages.",
    "crumbs": [
      "Basics in R",
      "Getting help"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "Using functions is a great way to generalize and automatize processes. R comes with several basic functions implemented in packages (which are basic collections of functions and objects) such as stats and graphics. Functions will usually take arguments provided by the user based on which they will perform an action. It is always important to read the Help page of a function to learn which arguments are possible and how to use them.\nFor example, you can use a function to generate a sequence more complex than just by using 1:10 using the arguments by and length.out of the function seq:\n\nseq(from = 1, to = 20, by = 2)  ## increment the sequence by 2\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\nseq(from = 1, to = 20, length.out = 5)  ## only 5 numbers between 1 and 20\n\n[1]  1.00  5.75 10.50 15.25 20.00\n\n\nA sequence can also be created by repetitions using the function rep and defining arguments as each (each element is repeated x times) and times (the sequence is repeated x times).\n\nrep(1:4, each = 2)\n\n[1] 1 1 2 2 3 3 4 4\n\nrep(c(\"cat\", \"dog\", \"mouse\"), times = 2)\n\n[1] \"cat\"   \"dog\"   \"mouse\" \"cat\"   \"dog\"   \"mouse\"\n\nrep(c(\"cat\", \"dog\", \"mouse\"), times = 1:3)\n\n[1] \"cat\"   \"dog\"   \"dog\"   \"mouse\" \"mouse\" \"mouse\"\n\n\nWe saw before that a logical operation can be made for each element in a vector using logical operators. If you want to check whether all or any elements fit a certain criterium you can use the functions:\n\nvec.1 &lt;- c(2, 4, 6)\nall(vec.1&lt;4)\n\n[1] FALSE\n\nany(vec.1&lt;4)\n\n[1] TRUE\n\n\nThe base packages in R also include functions to perform more complex but very useful calculations, such as logarithms (with different bases) and antilogs, square roots, sums, means and medians.\n\nlog(42)  ## natural log\n\n[1] 3.73767\n\nlog10(42)  ## base 10 log\n\n[1] 1.623249\n\nexp(3.73767)  ## antilog\n\n[1] 42.00002\n\nX = 13^2\nsqrt(X) == 13\n\n[1] TRUE\n\nvec &lt;- seq(1, 100, by = 2)\nsum(vec)\n\n[1] 2500\n\nmean(vec)\n\n[1] 50\n\nmedian(vec)\n\n[1] 50\n\n\nChecking the range of values in a list, the minimum and maximum values, and the length of this list can be very useful. As well as sorting a list or selecting which values correspond to a criterium.\n\nrange(vec)\n\n[1]  1 99\n\nmax(vec)\n\n[1] 99\n\nmin(vec)\n\n[1] 1\n\nlength(vec)\n\n[1] 50\n\nsort(vec)\n\n [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49\n[26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99\n\nrev(vec)\n\n [1] 99 97 95 93 91 89 87 85 83 81 79 77 75 73 71 69 67 65 63 61 59 57 55 53 51\n[26] 49 47 45 43 41 39 37 35 33 31 29 27 25 23 21 19 17 15 13 11  9  7  5  3  1\n\nwhich(vec == 3)  ## gives the position in the list\n\n[1] 2\n\n\nWe saw before how to see the class of an object using the class() function, but we can also check whether an object is from a specific class using the group of functions “is.X”:\n\nis.numeric(vec)\n\n[1] TRUE\n\nis.character(vec)\n\n[1] FALSE\n\n\nFactor is an object type that represent categorical variables. They have a determined number levels (categories), and some functions can be used to check those.\n\ncolor.names &lt;- factor(c(\"black\", \"white\", \"pink\", \"pink\", \"white\", \"white\"))\nclass(color.names)\n\n[1] \"factor\"\n\nlength(color.names)\n\n[1] 6\n\nlevels(color.names)\n\n[1] \"black\" \"pink\"  \"white\"\n\nlength(levels(color.names))\n\n[1] 3\n\n# there is also a function to do that\nnlevels(color.names)\n\n[1] 3\n\n\nLet’s say you want to calculate the mean value of a sequence that contains NA. This will return an NA:\n\ny &lt;- c(4, NA, 7)\nmean(y)\n\n[1] NA\n\n\nSo, you need to deal with this NA before obtaining this mean value. You can identify its position and manually remove it, but this becomes impracticable as the dimensions of an object increase. You can replace the NA by another value, using the ifelse() function, but that will change the original data. Alternatively, you can omit the NAs from the calculation, either before (using the function na.omit()) or with an argument implemented in the mean() function:\n\n# Option 1. Manually removing NAs. Try to understand the series of code here\nis.na(y)  ## tells you which positions are NAs\n\n[1] FALSE  TRUE FALSE\n\ny[!is.na(y)]\n\n[1] 4 7\n\ny.removed &lt;- y[!is.na(y)]  \ny.removed\n\n[1] 4 7\n\nmean(y.removed)\n\n[1] 5.5\n\n# Option 2. Replacing NAs\ny.replaced &lt;- ifelse(test = is.na(y), yes = 0, no = y) \ny.replaced\n\n[1] 4 0 7\n\nmean(y.replaced)\n\n[1] 3.666667\n\n# Option 3. Omitting NAs\ny.omit &lt;- na.omit(y)\ny.omit\n\n[1] 4 7\nattr(,\"na.action\")\n[1] 2\nattr(,\"class\")\n[1] \"omit\"\n\nmean(y.omit)\n\n[1] 5.5\n\n# Option 4. Use an argument in mean()\nmean(y, na.rm = TRUE)\n\n[1] 5.5\n\n\nOn the next section we will see how you can write your own function.\n\nPackages\nIn this section we will install and load packages to use their functions. Packages available on the official R repository (the CRAN repository) can be installed using the function:\n\ninstall.packages(\"ggplot2\")\n\nInstalling a package does not make it readly available, they first need to be loaded on the session.\n\nlibrary(ggplot2)",
    "crumbs": [
      "Basics in R",
      "Functions"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "Objects and variables",
    "section": "",
    "text": "Of course R is more than a simple calculator. The great benefit of using such a language is being able to store the results of an operation into a variable (or an object) that can be used later in some subsequent operation or passed as an argument in a function. In R you can do that using either “&lt;-” (which passes the value from the right to the left; shortcut: Alt + -) or the “=”. They have the same effect, but keeping the usage of “=” for operations or passing a value as an argument and “&lt;-” for storing values in an object is usually better seen. Whatever you choose to use, keep it consistent.\nAn object in R is stored in the environment and can be accessed by just typing its name. An object can store anything, a number, a character string, a vector or list, a matrix or data frame, even functions. Keep in mind that R is case-sensitive! The class of an object can be checked using the class() function.\n\nY = 2\ny = 1\nY == y\n\n[1] FALSE\n\nclass(y)\n\n[1] \"numeric\"\n\nanswer = \"Y is not the same as y\"\nanswer\n\n[1] \"Y is not the same as y\"\n\nclass(answer)\n\n[1] \"character\"\n\nsequence &lt;- 1:10\nsequence\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nclass(sequence)\n\n[1] \"integer\"\n\nclass(class)\n\n[1] \"function\"\n\n\nOperations can be done with objects instead of numbers (such as Y == y above). You can also combine objects into different objects. For example, to create a matrix (2-dimensions object), you can combine two vectors (1D objects) using functions like rbind or cbind (check their Help pages using ?rbind. Check also the function c()).\n\nvec.1 &lt;- c(2, 4, 6)\nvec.2 &lt;- c(3, 5, 7)\nmatrix.1 &lt;- cbind(vec.1, vec.2)  ## binds by column\nmatrix.1\n\n     vec.1 vec.2\n[1,]     2     3\n[2,]     4     5\n[3,]     6     7\n\nmatrix.2 &lt;- rbind(vec.1, vec.2)  ## binds by row\nmatrix.2\n\n      [,1] [,2] [,3]\nvec.1    2    4    6\nvec.2    3    5    7\n\nvec.1 + vec.2\n\n[1]  5  9 13\n\nvec.1 &gt; 4\n\n[1] FALSE FALSE  TRUE\n\n\nThere is another class of objects in R called data frames that are used a lot by many functions due to its capacity of storing different data types and to have your dimensions changed after creation. For example, you cannot have one column with character strings and another with numbers in a matrix (it will convert the columns to the same type), but you can have that with a data frame. You can access single columns, rows or cells by using the row and/or column number between square brackets.\n\nvec.3 = c(\"A\", \"B\", \"C\")\ncbind(vec.3, vec.2)\n\n     vec.3 vec.2\n[1,] \"A\"   \"3\"  \n[2,] \"B\"   \"5\"  \n[3,] \"C\"   \"7\"  \n\ndf &lt;- data.frame(vec.3, vec.2)\ndf\n\n  vec.3 vec.2\n1     A     3\n2     B     5\n3     C     7\n\ndf[1,1]  ## row 1, column 1\n\n[1] \"A\"\n\ndf[,2]  ## column 2\n\n[1] 3 5 7\n\n\nA nice feature of a data frame is giving names to its columns and then calling them using the $ sign.\n\ncolnames(df) &lt;- c(\"characters\", \"numbers\")\ndf$characters\n\n[1] \"A\" \"B\" \"C\"\n\ndf$numbers\n\n[1] 3 5 7",
    "crumbs": [
      "Basics in R",
      "Objects and variables"
    ]
  },
  {
    "objectID": "syntax.html",
    "href": "syntax.html",
    "title": "Basic syntax",
    "section": "",
    "text": "To use R you need to pass a series of commands to the console that will perform the analyses you want. Instead of just remembering everything you’ve done and typing the commands directly on the console, it is useful to use a text editor and create a script, in which you can keep track of what you want to do. RStudio has a built-in text editor that highlights the different elements used in R language, so it can be very useful. With it you can type all the functions and commands you need and save them in a .R script format. But you can also use any other text editors you like and have your script saved as a .txt file instead. As long as you pass the commands to the console, everything is fine. From now one, we will be using the RStudio text editor.\nEverything you type in the script can be interpreted either as code, unless you tag it as code:\n\n# This is how you type a comment. The following is code:\n\n2 + 2\n\n[1] 4\n\n\nCode should be thought and written in a self-explanatory manner. But, at least when you are learning, commenting your code will be very helpfult to remember what (and how) you did before. It is also very useful to keep a cohesive and clean code. Use for example a series of hashtags (#) to create section breakers with titles, and also try to avoid very long lines, breaking the code when possible.\n\n################################################################################\n# This is a new section\n\n# Instead of writing like this:\nplot(x = SCL, y = SCm, log = \"xy\", main = \"Skull vs. carapace length in Chelidae\", xlab = \"Carapace length (SCL)\", ylab = \"Skull lenght (SCm)\", bty = \"l\", cex = 0)\n\n# Try like this\nplot(x = SCL, \n     y = SCm, \n     log = \"xy\", \n     main = \"Skull vs. carapace length in Chelidae\",\n     xlab = \"Carapace length (SCL)\",\n     ylab = \"Skull lenght (SCm)\", \n     bty = \"l\",\n     cex = 0)",
    "crumbs": [
      "Basics in R",
      "Basic syntax"
    ]
  },
  {
    "objectID": "quarto.html",
    "href": "quarto.html",
    "title": "Creating documents in R - Quarto",
    "section": "",
    "text": "Quarto is a multi-language version of R Markdown (a file format for making dynamic documents with R) that allows you to easily create and render different types of documents in R, such as PDFs, .doc and .html files. Quarto files are saved with the extension .qmd. Quarto enables the usage of code blocks in the rendering that allows you to create fully reproducible documents by including links to the actual data and the code used to produce the output analyses or plots.\nThis page is based in the tutorials available on the official Quarto website. Access that page for a more detailed tutorial.\nDownload this Quarto document, open it in RStudio, and click on the  Render button.\nRStudio offers two ways of viewing and working with .qmd files: Source and Visual editors. In the Visual editor you see the file more similar to the way it will be rendered and can use the toolbar to format its content, whereas in the Source editor, you can edit the source code directly.\n\nRendering\nUse the  Render button in RStudio to render the file and preview the output with a single click. You can also use a keyboard shortcut (Ctrl + Shift + K in Windows or ⇧⌘K an Mac OS).\nWhen rendering, Quarto creates a new file that contains selected text, code, and results from the .qmd file. That file can be in many formats, including HTML and PDF.\nOpen the file you just downloaded to explore its contents.\n\n\nParts of a .qmd file\nMost of a Quarto file can be made of simple text, including formatting using Markdown notation. However, the power of Quarto comes from incorporating code in different languages that can transform the final document. Among those, we can cite the YAML header and code chunks in the text.\n\nYAML header\nAn optional YAML header is defined by three dashes (—) on both ends.\n\n---\ntitle: \"Hello, Quarto\"\nformat: html\neditor:visual\n---\n\nIn the rendered document, the title will appear at its top with a larger font size than the rest of the document. The format command denotes the format of the final document (in the example above, html, but it can be PDF or doc, for example). For each of those formats, there are several other YAML fields that can be added to the header (editor in the example denotes that the output should be open in the visual editor by default), such as author, subtitle, date, theme, and fontcolor.\n\n\nCode chunks\nCode chunks in a Quarto file can be used for many purposes, such as plotting figures or creating tables. Quarto accepts different programming languages in such chunks, for example python and, most important for our course, R. Code chunks are denote by three backticks (`) on both ends.\nR code chunks are identified by {r} with optional options, in YAML style, identified by #| at the beginning of the line.\n\n```{r}\n#| label: load-packages\n#| include: false\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n```\n\nIn this case, the label of the chunk is load-packages and we set include to false to indicate that we do not want the chunk itself or any of its outputs in the rendered document. There are many other options that can be used to tailor code chunks. For example, by default the code and its output are displayed within the rendered document, but setting echo and output to false omits both the commands and results from the document. Here are two examples, first including the source code:\n\nlibrary(ggplot2)\n\nggplot(mpg, aes(x = hwy, y = cty, color = cyl)) +\n  geom_point(alpha = 0.5, size = 2) +\n  scale_color_viridis_c() +\n  theme_minimal()\n\n\n\n\n\n\n\n\nAnd omitting it:\n\n\n\n\n\n\n\n\n\nIt is also possible to improve the appearance and accessibility of plots in the rendered file, by changing its dimensions, providing a caption, or adding alternative texts. We can also add multiple figures in the same plot. Let’s add the following chunk options and a second figure to our previous plot and compare the differences:\n\n```{r}\n#| label: fig-scatterplot\n#| fig-cap: \"City and highway mileage for 38 popular models of cars.\"\n#| fig-alt: \"The plots in @fig-mpg show the relationship between city and highway mileage for 38 popular models of cars. In @fig-mpg-1 the points are colored by the number of cylinders while in @fig-mpg-2 the points are colored by engine displacement.\"\n#| fig-subcap:\n#|   - \"Color by number of cylinders\"\n#|   - \"Color by engine displacement, in liters\"\n#| layout-ncol: 2\n#| fig-height: 5\n#| echo: false\n```\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Color by number of cylinders\n\n\n\n\n\n\n\n\n\n\n\n(b) Color by engine displacement, in liters\n\n\n\n\n\n\n\nFigure 1: City and highway mileage for 38 popular models of cars.\n\n\n\n\n\n\nPDFs\nIn order to create PDFs using Quarto you will need to install a recent distribution of LaTeX. TinyTeX is commonly recommended and can be installed in the RStudio Terminal using:\n\nquarto install tinytex\n\nIn order to explore different option to create a PDF you can download the file authoring.qmd. After installing a LaTeX distribution you should be able to render it and create a PDF document with the results. In the third Quarto tutorial you can find out about additional elements of a document, such as creating cross references or citations.",
    "crumbs": [
      "Basics in R",
      "Creating documents in R - Quarto"
    ]
  },
  {
    "objectID": "quarto.html#yaml-header",
    "href": "quarto.html#yaml-header",
    "title": "Creating documents in R - Quarto",
    "section": "YAML header",
    "text": "YAML header\nAn optional YAML header is defined by three dashes (—) on both ends.\n\n---\ntitle: \"Hello, Quarto\"\nformat: html\neditor:visual\n---"
  }
]